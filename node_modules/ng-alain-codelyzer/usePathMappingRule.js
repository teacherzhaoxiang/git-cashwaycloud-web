"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var Lint = require("tslint");
exports.IMPORT_SEP = '/';
var Rule = (function (_super) {
    __extends(Rule, _super);
    function Rule(options) {
        var _this = _super.call(this, options) || this;
        _this.fileSplitWord = getName('src', 'app', 'routes');
        var args = _this.getOptions().ruleArguments;
        var pathMapping = args[1] || ['@core', '@shared'];
        if (!(pathMapping instanceof Array)) {
            pathMapping = [pathMapping];
        }
        _this.pathMappings = parseOptions(pathMapping);
        return _this;
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new Walker(sourceFile, this));
    };
    Rule.metadata = {
        ruleName: 'use-path-mapping',
        description: "Importing the core directory in the router directory must use the `@core` prefix.",
        descriptionDetails: "https://ng-alain.com/docs/styleguide#path-mapping",
        options: {
            items: {
                type: 'string',
            },
            minLength: 0,
            type: 'array',
        },
        optionExamples: [true, ['@core', '@shared']],
        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    "], ["\n    "]))),
        rationale: "Consistent conventions make it easy to quickly identify and reference assets of different types.",
        type: 'typescript',
        typescriptOnly: true,
        hasFix: true,
    };
    Rule.FAILURE_STRING = 'Use the @Input property decorator instead of the inputs property';
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function parseOptions(list) {
    var res = [];
    list
        .filter(function (key) { return key.startsWith('@'); })
        .forEach(function (key) {
        var sepArr = key.split(exports.IMPORT_SEP);
        var item = {
            prefix: sepArr[0].substr(1),
            allowSubdirectories: sepArr.length > 1,
        };
        res.push(item);
    });
    return res;
}
function getName() {
    var pathArr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        pathArr[_i] = arguments[_i];
    }
    return path.normalize(path.join.apply(path, pathArr)).replace(/\\/g, exports.IMPORT_SEP);
}
function removeQuotes(value) {
    if (value.length > 1 && (value[0] === "'" || value[0] === '"')) {
        value = value.substr(1, value.length - 2);
    }
    return value;
}
function getMapping(key, pathMapping) {
    return pathMapping.find(function (w) { return w.prefix === key; });
}
function getImportFilePath(sourceFile, text) {
    var sourceFileValidPath = sourceFile.split(exports.IMPORT_SEP).join(path.sep);
    return getName(path.resolve(sourceFileValidPath, text));
}
exports.getFailureMessage = function (newText) {
    return "Should be imported using `" + newText + "`";
};
var Walker = (function (_super) {
    __extends(Walker, _super);
    function Walker(sourceFile, rule) {
        var _this = _super.call(this, sourceFile, rule.getOptions()) || this;
        _this.rule = rule;
        _this.isValidRoutePath = false;
        _this.sourceFilePath = '';
        _this.sourceFilePath = sourceFile.fileName;
        _this.isValidRoutePath = sourceFile.fileName.indexOf(_this.rule.fileSplitWord) !== -1;
        return _this;
    }
    Walker.prototype.getValidImportPath = function (text) {
        var sepArr;
        if (text[0] === '@') {
            sepArr = text.substr(1).split(exports.IMPORT_SEP);
        }
        else {
            var importPathSeqArr = getImportFilePath(this.sourceFilePath, text).split(this.rule.fileSplitWord);
            if (importPathSeqArr.length === 1) {
                return null;
            }
            sepArr = importPathSeqArr[1].split(exports.IMPORT_SEP).filter(function (w) { return !!w; });
        }
        var mapping = getMapping(sepArr[0], this.rule.pathMappings);
        if (!mapping || (sepArr.length > 1 && mapping.allowSubdirectories)) {
            return null;
        }
        var newText = "@" + mapping.prefix;
        return newText === text ? null : newText;
    };
    Walker.prototype.getFix = function (start, text, newText) {
        var fix = [];
        fix.push(Lint.Replacement.deleteText(start + 1, text.length));
        fix.push(Lint.Replacement.appendText(start + 1, newText));
        return fix;
    };
    Walker.prototype.visitImportDeclaration = function (node) {
        if (!this.isValidRoutePath) {
            return;
        }
        var text = removeQuotes(node.moduleSpecifier.getText());
        var newText = this.getValidImportPath(text);
        if (newText == null) {
            return;
        }
        var start = node.moduleSpecifier.getStart();
        var fix = this.getFix(start, text, newText);
        this.addFailureAt(start + 1, text.length, exports.getFailureMessage(newText), fix);
    };
    return Walker;
}(Lint.RuleWalker));
var templateObject_1;
